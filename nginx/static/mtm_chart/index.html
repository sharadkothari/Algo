<!DOCTYPE html>
<html>
<head>
    <title>MTM Chart</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
        }

        #controls {
            padding: 0px;
            background-color: #f0f0f0;
            flex-shrink: 0;
        }

        #chart {
            width: 100%;
            flex-grow: 1;
        }
    </style>
</head>
<body>
    <div id="controls">
        <select id="broker-select"></select>
    </div>

    <div id="chart"></div>

<script>
    const apiBase = "/api/bpd";
    let selectedBroker = null;
    const lastIds = {};
    const chartData = {};

    async function loadBrokersAndPlot() {
        try {
            const res = await fetch(`${apiBase}/brokers`);
            const brokers = await res.json();
            const dropdown = document.getElementById("broker-select");

            if (!selectedBroker || !brokers.includes(selectedBroker)) {
                selectedBroker = brokers[0] || null;
            }

            dropdown.innerHTML = "";
            brokers.forEach(broker => {
                const option = document.createElement("option");
                option.value = broker;
                option.textContent = broker;
                if (broker === selectedBroker) option.selected = true;
                dropdown.appendChild(option);
            });

            if (selectedBroker) {
                await fetchAndPlot(selectedBroker);
            }
        } catch (error) {
            console.error("Error in loadBrokersAndPlot:", error);
        }
    }

    async function fetchAndPlot(broker) {
        try {
            const lastId = lastIds[broker] || '0';
            const response = await fetch(`${apiBase}/mtm-data?broker=${encodeURIComponent(broker)}&last_id=${lastId}`);
            const result = await response.json();

            const newPoints = result.data || [];
            if (!chartData[broker]) chartData[broker] = [];

            chartData[broker].push(...newPoints);

            // Clean and sort the data
            chartData[broker] = chartData[broker]
                .map(d => {
                    const mtm = parseFloat(d.MTM);
                    const time = new Date(d.timestamp);
                    if (isNaN(mtm) || isNaN(time.getTime())) return null;
                    return { timestamp: time, MTM: mtm };
                })
                .filter(Boolean)
                .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            lastIds[broker] = result.last_id || lastId;

            const posX = [], posY = [], negX = [], negY = [];

            chartData[broker].forEach(d => {
                if (d.MTM >= 0) {
                    posX.push(d.timestamp);
                    posY.push(d.MTM);
                    negX.push(null);
                    negY.push(null);
                } else {
                    posX.push(null);
                    posY.push(null);
                    negX.push(d.timestamp);
                    negY.push(d.MTM);
                }
            });

            // If there's no valid data, do not attempt to plot
            if (posX.every(x => x === null) && negX.every(x => x === null)) {
                console.warn("No valid MTM points to plot for broker:", broker);
                document.getElementById("chart").innerHTML = "<p style='text-align:center;padding-top:20px;'>No MTM data available.</p>";
                return;
            }

            // Safely find the last valid point
            let lastX = null, lastY = null;
            for (let i = chartData[broker].length - 1; i >= 0; i--) {
                const d = chartData[broker][i];
                if (d && d.timestamp && !isNaN(d.MTM)) {
                    lastX = d.timestamp;
                    lastY = d.MTM;
                    break;
                }
            }

            const layout = {
                autosize: true,
                margin: { l: 60, r: 20, b: 40, t: 30, pad: 0 },
                showlegend: false,
                xaxis: {
                    type: 'date',
                    title: 'Time',
                    tickformat: '%H:%M:%S'
                },
                yaxis: {
                    title: 'MTM',
                    automargin: true
                },
                annotations: (lastX !== null && lastY !== null) ? [{
                    x: lastX,
                    y: lastY,
                    xref: 'x',
                    yref: 'y',
                    text: `${Math.round(lastY)}`,
                    showarrow: true,
                    arrowhead: 7,
                    ax: 40,
                    ay: 0,
                    font: { color: 'blue', size: 12 },
                    bgcolor: 'white',
                }] : []
            };

            Plotly.newPlot("chart", [
                {
                    x: posX,
                    y: posY,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Positive MTM',
                    line: { color: 'green' }
                },
                {
                    x: negX,
                    y: negY,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Negative MTM',
                    line: { color: 'red' }
                }
            ], layout, { responsive: true });

        } catch (error) {
            console.error("Error fetching MTM data:", error);
        }
    }

    document.getElementById("broker-select").addEventListener("change", (e) => {
        selectedBroker = e.target.value;
        if (!chartData[selectedBroker]) {
            chartData[selectedBroker] = [];
            lastIds[selectedBroker] = '0';
        }
        fetchAndPlot(selectedBroker);
    });

    window.addEventListener("resize", () => {
        Plotly.relayout("chart", { autosize: true });
    });

    loadBrokersAndPlot();
    setInterval(() => {
        if (selectedBroker) {
            fetchAndPlot(selectedBroker);
        }
    }, 5000);
</script>

</body>
</html>
